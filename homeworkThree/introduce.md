# 1. 连续线段

## 1.1 问题描述

平面上两个点可构成一个线段，两个线段如果有一个端点相同，则可构成一个连续线段。

假设构成线段的两个端点为$v_1(x_1,y_1)$和$v_2(x_2,y_2)$，满足$x_1<x_2$，其中$v_1$称为线段的起点，$v_2$为线段的终点。同样，对于连续线段来说，满足$x_i<x_{i+1}$。

输入一组线段，用两个端点的$x$、$y$坐标表示线段，线段个数大于等于$2$，小于等于$100$，编程计算出连续线段中**包含最多线段数**的线段，输出相应的线段数和起点位置。

提交文件名为`"lines.c"`

## 1.2 输入形式

先从控制台输入线段数，然后从下一行开始分行输入各线段两个端点的$x$、$y$坐标，其中第一个端点的$x$轴坐标小于第二个端点的$x$轴坐标，即$x_1<x_2$。$x$、$y$坐标都用整数表示，不会超过`int`的表示范围，各整数坐标值间以一个空格分隔。

## 1.3 输出形式

先在控制台输出包含最多线段数的连续线段的线段数，然后输出连续线段的起点的$x$、$y$坐标，输出数据都以一个空格分隔。

## 1.4 样例

输入

```
10
80 75 125 75
60 40 80 55
80 55 90 20
140 120 195 205
10 111 70 165
22 35 43 43
22 175 80 205
43 43 60 40
90 20 125 60
70 165 140 120
```

输出

```
5 22 35
```

# 2. 空闲空间申请模拟

## 2.1 问题描述

在操作系统中，空闲存储空间通常以空闲块链表方式组织，每个块包含块起始位置、块长度及一个指向下一块的指针。空闲块按照存储位置升序组织，最后一块指向第一块，从而构成循环链表。当有空间申请请求时，按照如下原则在空闲块循环链表中寻找并分配空闲块：

1. 从当前位置开始遍历空闲块链表（初始是从地址最小的第一个空闲块开始）寻找满足条件的最小块（即大于等于请求空间的最小空闲块，如果有多个大小相同的最小空闲块，则选择遍历遇到的第一个空闲块，即最佳适应原则）
2. 如果选择的空闲块恰好与请求的大小相符合，则将它从链表中移除并返回给用户；这时当前位置变为移除的空闲块指向的下一空闲块
3. 如果选择的空闲块大于所申请的空间大小，则将大小合适的空闲块返回给用户，剩下的部分留在空闲块链表中；这时当前位置仍然为该空闲块
4. 如果找不到足够大的空闲块，则申请失败；这时当前位置不变。

空闲块链表中每个结点表示一个空闲块，结点中上面的数字指空闲块的起始位置，即空闲块地址，下面的数字指空闲块的长度，位置和长度都用正整数表示，大小不超过`int`表示范围。

编写程序，模拟上述空闲空间申请。

提交文件名为`"memory.c"`

## 2.2 输入形式

先从控制台读入一正整数，表示当前空闲块的个数，空闲块个数大于0小于100

然后按照起始位置由小到大的顺序分行输入每个空闲块的起始位置和长度，位置和长度都用正整数表示，大小不超过`int`表示范围，两整数间以一个空格分隔。

最后在新的一行上依次输入申请空间的大小，以`-1`表示结束，各整数间以一个空格分隔，申请请求的个数不超过100个。

## 2.3 输出形式

按照上述原则模拟完空闲空间申请后，输出当前空闲空间链表状态，即从当前位置开始，遍历链表，分行输出剩余空闲块的起始位置和长度，位置和长度间以一个空格分隔。若申请完后，链表中没有空闲块，则什么都不输出。

## 2.4 样例

输入

```
12
1024 2048
8192 512
16384 1024
32768 8192
65536 8192
77824 1024
80896 3072
86016 1024
91136 5120
99328 512
104448 1024
112640 3072
1024 2560 10240 512 1024 6400 512 -1
```

输出

```
104448 1024
112640 3072
1024 2048
8192 512
32768 1792
65536 8192
77824 1024
91136 5120
```

# 3. 多项式相乘

## 3.1 问题描述

编写一个程序实现两个一元多项式相乘。建议使用链表实现。

提交文件名为`"multi.c"`

## 3.2 输入形式

首先输入第一个多项式中系数不为0的项的系数和指数，以一个空格分隔。且该多项式中各项的指数均为`0`或正整数，系数和最高幂次不会超过`int`类型的表示范围。

对于多项式
$$
a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x^1+a_0x^0
$$
的输入方法如下：

```
an n an-1 n-1 ... a1 1 a0 0
```

即相邻两个整数分别表示表达式中一项的系数和指数。在输入中只出现系数不为0的项。最后一项的指数后没有空格，只有一个回车换行符。按照上述方式再输入第二个多项式。

## 3.3 输出形式

将运算结果输出到屏幕。将系数不为0的项按指数从高到低的顺序输出，每次输出其系数和指数，均以一个空格分隔，最后一项的指数后也可以有一个空格。

## 3.4 样例

输入

```
10 80000 2 6000 7 300 5 10 18 0
3 6000 5 20 8 10 6 0
```

输出

```
30 86000 50 80020 80 80010 60 80000 6 12000 21 6300 10 6020 31 6010 66 6000 35 320 56 310 42 300 25 30 130 20 174 10 108 0
```

# 4. 文件加密

## 4.1 问题描述

有一种文本文件加密方法，其方法如下：

1. 密钥由所有ASCII码可见字符（ASCII码编码值32-126为可见字符）组成，密钥长度不超过32个字符；
2. 先将密钥中的重复字符去掉，即：只保留最先出现的字符，其后出现的相同字符都去掉；
3. 将不含重复字符的密钥和其它不在密钥中的可见字符（按字符升序）连成一个由可见字符组成的环，密钥在前，密钥的头字符为环的起始位置；
4. 设原密钥的第一个字符（即环的起始位置）作为环的开始位置标识，先从环中删除第一个字符（位置标识则移至下一个字符），再沿着环从下一个字符开始顺时针以第一个字符的ASCII码值移动该位置标识至某个字符，则该字符成为第一个字符的密文字符；然后从环中删除该字符，再从下一个字符开始顺时针以该字符的ASCII码值移动位置标识至某个字符，找到该字符的密文字符；依次按照同样方法找到其它字符的密文字符。当环中只剩一个字符时，则该剩下的最后一个字符的密文为原密钥的第一个字符。

以可见字符集只由小写字母组成为例来说明对应密文字符集生成过程。

如果密钥为`helloworld`，将密钥中重复字符去掉后为`helowrd`，将不在密钥中的小写字母按照升序添加在密钥后，即形成字符串`helowrdabcfgijkmnpqstuvxyz`。

明码的第一个字母为`h`，`h`也是环的起始位置。`h`的ASCII码值为104，先把`h`从环中删除，再从下一个字母`e`开始顺时针沿着环按其ASCII值移动位置标识（即：在字母e为移动第1次，共移动位置标识104次）至字母`w`，则`h`的密文字符为`w`。`w`的ASCII码制为119，然后将`w`从环中删除，再从下一个字母`r`开始顺时针沿着环移动位置标识`119`次至字母为`l`，则`w`的密文字符为`l`。依次按照同样方法找到其它字母的密文字符。环中剩下的最后一个字母为`x`，则`x`的密文字符为明码的第一个字母`h`。

按照这种方法形成的密文转换字符表为

| a    | b    | c    | d    | e    | f    | g    | h    | i    | j    | k    | l    | m    | n    | o    | p    | q    | r    | s    | t    | u    | v    | w    | x    | y    | z    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| q    | g    | k    | c    | d    | r    | o    | w    | x    | u    | t    | s    | f    | i    | m    | b    | z    | a    | y    | v    | n    | j    | l    | h    | p    | e    |

上方为原文字符，下方为对应的密文字符。由所有ASCII可见字符集组成的字符集密文字符生成方式与上例相同。

编写程序实现上述文件加密方法。密钥从标准输入读取，待加密文件为当前目录下的`"in.txt"`文件，该文件中的字符若是可见字符，则按照上述方法进行加密，否则原样输出。加密后生成的密文文件为当前目录下的`"in_crpyt.txt"`。

提交文件名为`"encode.c"`

## 4.2 输入形式

密钥是从标准输入读取的一行字符串，可以包含任意ASCII码可见字符，即ASCII码编码值32-126的字符，长度不超过32个字符。

## 4.3 输出形式

加密后生成的密文文件为当前目录下的`"in_crpyt.txt"`。

## 4.4 样例

控制台输入为

```
C Programming(Second Edition)
```

in.txt文件内容为

```
This book is meant to help the reader learn how to program in C. It is the definitive reference guide, now in a second edition. Although the first edition was written in 1978, it continues to be a worldwide best-seller. This second edition brings the classic original up to date to include the ANSI standard.
From the Preface:
```

in_crpyt.txt文件内容为

```
KgklW#33>WklWA\^M8W83Wg\Z,W8g\WP\^u\PWZ\^PMWg3jW83W,P30P^AWkMWX5W.8WklW8g\Wu\EkMk8kt\WP\E\P\MR\W0-ku\+WM3jWkMW^Wl\R3MuW\uk8k3M5WIZ8g3-0gW8g\WEkPl8W\uk8k3MWj^lWjPk88\MWkMW'71G+Wk8WR3M8kM-\lW83W#\W^Wj3PZujku\W#\l8Jl\ZZ\P5WKgklWl\R3MuW\uk8k3MW#PkM0lW8g\WRZ^llkRW3Pk0kM^ZW-,W83Wu^8\W83WkMRZ-u\W8g\WIOY.Wl8^Mu^Pu5
4P3AW8g\WdP\E^R\(
```

# 5. 词频统计

## 5.1 问题描述

编写程序统计一个英文文本文件中每个单词的出现次数，并将统计结果按单词字典序输出到屏幕上。注意在此单词为仅由字母组成的字符序列，包含大写字母的单词应将大写字母转换为小写字母后统计。

## 5.2 输入形式

打开当前目录下文件`“article.txt”`，从中读取英文单词进行词频统计。

## 5.3 输出形式

程序将单词统计结果按单词字典序输出到屏幕上，每行输出一个单词及其出现次数，单词和其出现次数间由一个空格分隔，出现次数后直接换行。

## 5.4 样例

article.txt文件内容为

```
“Do not take to heart every thing you hear.”
“Do not spend all that you have.”
“Do not sleep as long as you want;”
```

控制台输出为

```
all 1
as 2
do 3
every 1
have 1
hear 1
heart 1
long 1
not 3
sleep 1
spend 1
take 1
that 1
thing 1
to 1
want 1
you 3
```

